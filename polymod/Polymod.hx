package polymod;

import haxe.Json;
import haxe.io.Bytes;
import polymod.backends.IBackend;
import polymod.backends.PolymodAssetLibrary;
import polymod.backends.PolymodAssets;
import polymod.format.JsonHelp;
import polymod.format.ParseRules;
import polymod.fs.PolymodFileSystem;
#if hscript
import polymod.hscript._internal.PolymodScriptClass;
#end
import polymod.util.DependencyUtil;
import polymod.util.VersionUtil;
import thx.semver.Version;
import thx.semver.VersionRule;

using StringTools;

#if firetongue
import firetongue.FireTongue;
#end

/**
 * The set of parameters which can be provided when intializing Polymod
 */
typedef PolymodParams =
{
	/**
	 * (optional) The root directory for your game's mods.
	 * On `SysFileSystem` (the default filesystem for desktop platforms), this parameter is required.
	 */
	?modRoot:String,

	/**
	 * (optional) The mods that should be loaded, listed as their directory names relative to modRoot
	 * If not provided, Polymod will initialize with no mods loaded.
	 */
	?dirs:Array<String>,
	/**
	 * (optional) The Haxe framework currently in use.
	 * This is used to determine the proper backend injection methods to use.
	 * If not provided, Polymod will attempt to determine this automatically.
	 * Set to `CUSTOM` if you're using a custom backend.
	 */
	?framework:Framework,
	/**
	 * (optional) Configuration specific to the framework currently in use.
	 */
	?frameworkParams:FrameworkParams,
	/**
	 * (optional) Semantic Version rule of your game's modding API.
	 * Provide a value as a string, like `"3.0.0"` or `"2.x"`.
	 * If provided, Polymod will invalidate any mods whose versions are not compatible with this rule.
	 */
	?apiVersionRule:VersionRule,
	/**
	 * (optional) A callback function which receives log and error messages generated by Polymod.
	 * Check the `severity` to determine if the message is a notice or an error,
	 * and use the `code` to determine the exact problem that occurred (and maybe provide a custom error or handling for it).
	 */
	?errorCallback:PolymodError->Void,
	/**
	 * (optional) Parsing rules for various data formats.
	 * Used to provide information on how to append and merge various data formats.
	 * Defaults to `ParseRules.getDefault()`.
	 */
	?parseRules:ParseRules,
	/**
	 * (optional) A list of filenames to ignore within mods.
	 * By default, this will ignore license files, the mod metadata file, and mod icon file.
	 */
	?ignoredFiles:Array<String>,
	/**
	 * (optional) Your own custom file backend for handling modded assets.
	 * This can let you integrate Polymod with a game engine which normally isn't supported.
	 * Set the `framework` parameter to `CUSTOM` and provide a class implementing `IBackend`.
	 */
	?customBackend:Class<IBackend>,
	/**
	 * (optional) A map associating different file extensions with different file types.
	 * This tells Polymod to handle certain assets as text, certain assets as images, etc.
	 */
	?extensionMap:Map<String, PolymodAssetType>,
	/**
	 * (optional) Your own custom backend for accessing the file system.
	 *
	 * By default, Polymod will load mods from your local native filesystem.
	 * This parameter lets you provide your own filesystem implementation.
	 * This is important if you want to support HTML5, or load mods from a remote server, or something custom.
	 * You can either write your own filesystem, or use one of the ones provided in the `polymod.fs` package.
	 *
	 * This parameter takes either an instance of `IFileSystem` or a `Class<T>` implementing `IFileSystem`.
	 */
	?customFilesystem:Dynamic,
	/**
	 * (optional) A set of parameters for initializing the filesystem.
	 * Some filesystems may ignore some of these parameters.
	 */
	?fileSystemParams:PolymodFileSystemParams,
	/**
	 * (optional) Specify the name of your assets folder.
	 * Defaults to `assets/`; if your assets folder is not named `assets/`, you can specify the correct name here.
	 * This prevents some bugs when calling `Assets.list()`, among other things.
	 */
	?assetPrefix:String,
	/**
	 * (optional) Disables dependency checks. Defaults to `false`.
	 * By default, Polymod will query all the loaded mods, and either exclude mods whose dependencies are not met,
	 * or reorganize the load order to ensure that mods are loaded after their dependencies.
	 *
	 * Setting this to `true` will disable this behavior entirely.
	 * Mods will be loaded in the order they are provided.
	 *
	 * This is NOT recommended as issues may result from loading mods in the wrong order,
	 * or while loading a mod with a missing dependency.
	 */
	?skipDependencyChecks:Bool,
	/**
	 * (optional) If `false`, Polymod will completely stop loading mods if any mods have missing dependencies.
	 * If `true`, Polymod will skip loading mods that have missing dependencies, but will continue loading other mods.
	 *
	 * Defaults to `false`.
	 */
	?skipDependencyErrors:Bool,

	/**
	 * (optional) A FireTongue instance for Polymod to hook into.
	 * This is used for robust support for asset localization
	 */
	#if firetongue
	?firetongue:FireTongue,
	#end
	/**
	 * (optional) Whether to perform the required initialization for scripted classes.
	 *
	 * Defaults to `false`.
	 */
	?useScriptedClasses:Bool,

	/**
	 * (optional) If `useScriptedClasses` is true, perform script loading asynchronously.
	 *
	 * Defaults to `false`.
	 */
	?loadScriptsAsync:Bool,
}

/**
 * Any framework-specific settings
 * Right now this is only used to specify asset library paths for the Lime/OpenFL framework but we'll add more framework-specific settings here as neeeded
 */
typedef FrameworkParams =
{
	/**
	 * (optional) if you're using Lime/OpenFL AND you're using custom or non-default asset libraries, then you must provide a key=>value store mapping the name of each asset library to a path prefix in your mod structure
	 */
	?assetLibraryPaths:Map<String, String>,

	/**
	 * (optional) specify this path to redirect core asset loading to a different path
	 * you can set this up to load core assets from a parent directory!
	 * Not applicable for file systems which don't use a directory obvs.
	 */
	 ?coreAssetRedirect:String
}

typedef ScanParams =
{
	?modRoot:String,
	?apiVersionRule:VersionRule,
	?errorCallback:PolymodError->Void,
	?fileSystem:IFileSystem
}

/**
 * The framework which your Haxe project is using to manage assets
 */
enum Framework
{
	CASTLE;
	NME;
	LIME;
	OPENFL;
	OPENFL_WITH_NODE;
	FLIXEL;
	HEAPS;
	KHA;
	CERAMIC;
	CUSTOM;
	UNKNOWN;
}


@:allow(polymod.hscript._internal.PolymodScriptClass)
class Polymod
{
	/**
	 * The callback function for any errors or notices generated by Polymod.
	 * Populate this by calling `init({errorCallback = myCallback})`.
	 */
	public static var onError:PolymodError->Void = null;

	/**
	 * The internal asset library used by Polymod.
	 */
	private static var assetLibrary:PolymodAssetLibrary = null;

	#if firetongue
	/**
	 * A FireTongue instance for Polymod to hook into for asset localization support.
	 */
	private static var tongue:FireTongue = null;
	#end

	/**
	 * The PolymodParams used when `init()` was last called.
	 */
	private static var prevParams:PolymodParams = null;

	/**
	 * Initializes Polymod, while loading the chosen mod or mods.
	 *
	 * @param params A set of parameters to use when initializing Polymod.
	 * @return An array of metadata entries for the mods which were successfully loaded.
	 */
	public static function init(params:PolymodParams):Array<ModMetadata>
	{
		if (params.errorCallback != null)
			onError = params.errorCallback;

		var modRoot = params.modRoot;
		if (modRoot == null)
		{
			if (params.fileSystemParams.modRoot != null)
			{
				modRoot = params.fileSystemParams.modRoot;
			}
			else
			{
				modRoot = './mods';
			}
		}
		var dirs = params.dirs == null ? [] : params.dirs;

		if (params.fileSystemParams == null)
			params.fileSystemParams = {modRoot: modRoot};
		if (params.fileSystemParams.modRoot == null)
			params.fileSystemParams.modRoot = modRoot;
		if (params.apiVersionRule == null)
			params.apiVersionRule = VersionUtil.DEFAULT_VERSION_RULE;
		var fileSystem = PolymodFileSystem.makeFileSystem(params.customFilesystem, params.fileSystemParams);

		// Fetch mod metadata and exclude broken mods.
		var modsToLoad:Array<ModMetadata> = [];

		for (i in 0...dirs.length)
		{
			if (dirs[i] != null)
			{
				var modId = dirs[i];
				var meta:ModMetadata = fileSystem.getMetadata(modId);

				if (meta != null)
				{
					if (!VersionUtil.match(meta.apiVersion, params.apiVersionRule))
					{
						error(VERSION_CONFLICT_API,
							'Mod "${modId}" was built for incompatible API version ${meta.apiVersion.toString()}, expected "${params.apiVersionRule.toString()}"',
							INIT);
					}

					// API version matches
					modsToLoad.push(meta);
				}
			}
		}

		// Sort mods by dependencies.
		var sortedModsToLoad:Array<ModMetadata> = modsToLoad;

		if (!params.skipDependencyChecks)
		{
			sortedModsToLoad = DependencyUtil.sortByDependencies(modsToLoad, params.skipDependencyErrors);
			if (sortedModsToLoad == null)
			{
				sortedModsToLoad = [];
			}
		}
		else
		{
			Polymod.warning(DEPENDENCY_CHECK_SKIPPED, "Dependency checks were skipped.");
		}

		// Get the file path for each mod to load, in order.
		var sortedModPaths:Array<String> = sortedModsToLoad.map(function(meta:ModMetadata):String
		{
			return meta.modPath;
		});

		assetLibrary = PolymodAssets.init({
			framework: params.framework,
			dirs: sortedModPaths,
			parseRules: params.parseRules,
			ignoredFiles: params.ignoredFiles,
			customBackend: params.customBackend,
			extensionMap: params.extensionMap,
			frameworkParams: params.frameworkParams,
			fileSystem: fileSystem,
			assetPrefix: params.assetPrefix,
			#if firetongue
			firetongue: params.firetongue,
			#end
		});

		if (assetLibrary == null)
		{
			// Polymod failed to initialize.
			return null;
		}

		// If we're here... Polymod initialized successfully!
		// Time for some post-initialization cleanup.

		// Store the params for later use (by loadMod, unloadMod, and clearMods)
		prevParams = params;

		// Do scripted class initialization now that the assetLibrary is loaded.
		#if hscript
		if (params.useScriptedClasses)
		{
			Polymod.notice(PolymodErrorCode.SCRIPT_PARSING, 'Parsing script classes...');

			if (params.loadScriptsAsync) {
				Polymod.registerAllScriptClassesAsync();
			} else {
				Polymod.registerAllScriptClasses();

				var classList = polymod.hscript._internal.PolymodScriptClass.listScriptClasses();
				Polymod.notice(PolymodErrorCode.SCRIPT_PARSED, 'Parsed and registered ${classList.length} scripted classes.');
			}
		}
		#else
		if (params.useScriptedClasses)
		{
			Polymod.warning(PolymodErrorCode.SCRIPT_HSCRIPT_NOT_INSTALLED, 'Scripted classes were requested, but hscript is not installed.');
		}
		#end

		return sortedModsToLoad;
	}

	public static function getLoadedModIds():Array<String>
	{
		return assetLibrary.dirs;
	}

	/**
	 * Retrieve the IFileSystem instance currently in use by Polymod.
	 * This may be useful if you're using a MemoryFileSystem or a custom file system that you want to call functions on.
	 */
	public static function getFileSystem():IFileSystem
	{
		if (assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot return file system.', INIT);
			return null;
		}
		return assetLibrary.fileSystem;
	}

	/**
	 * Reinitializes Polymod (with the same parameters) while additionally enabling an individual mod.
	 * The new mod will get added to the end of the modlist (unless mod dependencies require otherwise).
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already,
	 * you may have to call `clearCache()` for this to take effect.
	 *
	 * @return A list of all mods that were successfully loaded.
	 */
	public static function loadMod(modId:String):Array<ModMetadata>
	{
		// Check if Polymod is loaded.
		if (prevParams == null || assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot load mod "$modId".', INIT);
			return [];
		}

		var newParams = Reflect.copy(prevParams);
		// Add the mod to the list of mods to load.
		newParams.dirs = newParams.dirs.concat([modId]);
		// Keep the same file system between reloads.
		newParams.customFilesystem = assetLibrary.fileSystem;

		return Polymod.init(newParams);
	}

	/**
	 * Reinitializes Polymod (with the same parameters) while additionally enabling several mods.
	 * The new mods will get added to the end of the modlist (unless mod dependencies require otherwise).
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already.
	 * you may have to call `clearCache()` for this to take effect.
	 *
	 * @return A list of all mods that were successfully loaded.
	 */
	public static function loadMods(modIds:Array<String>):Array<ModMetadata>
	{
		// Check if Polymod is loaded.
		if (prevParams == null || assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot load mod "$modIds".', INIT);
			return [];
		}

		var newParams = Reflect.copy(prevParams);
		// Add the mods to the list of mods to load.
		newParams.dirs = newParams.dirs.concat(modIds);
		// Keep the same file system between reloads.
		newParams.customFilesystem = assetLibrary.fileSystem;

		return Polymod.init(newParams);
	}

	/**
	 * Reinitializes Polymod (with the same parameters) while enabling a list of mods.
	 * The new modlist will replace the old modlist.
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already.
	 * you may have to call `clearCache()` for this to take effect.
	 *
	 * @return A list of all mods that were successfully loaded.
	 */
	public static function loadOnlyMods(modIds:Array<String>):Array<ModMetadata>
	{
		// Check if Polymod is loaded.
		if (prevParams == null || assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot load mod "$modIds".', INIT);
			return [];
		}

		var newParams = Reflect.copy(prevParams);
		// Set the list of mods to load.
		newParams.dirs = modIds;
		// Keep the same file system between reloads.
		newParams.customFilesystem = assetLibrary.fileSystem;

		return Polymod.init(newParams);
	}

	/**
	 * Reinitializes Polymod, with the same parameters.
	 * Useful to force Polymod to detect newly added files.
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already,
	 * you may have to call `clearCache()` for this to take effect.
	 *
	 * @return A list of all mods that were successfully loaded.
	 */
	public static function reload():Array<ModMetadata>
	{
		var newParams = Reflect.copy(prevParams);
		// Keep the same file system between reloads.
		newParams.customFilesystem = assetLibrary.fileSystem;
		return Polymod.init(newParams);
	}

	/**
	 * Reinitializes Polymod (with the same parameters) while additionally disabling an individual mod.
	 * The specified mod will get removed from the modlist.
	 * If the unloaded mod was a dependency, depending on your configuration,
	 * either dependent mods will also be disabled, or Polymod will throw an error and unload nothing.
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already.
	 * you may have to call `clearCache()` for this to take effect.
	 *
	 * @return A list of all mods that were successfully loaded.
	 */
	public static function unloadMod(modId:String):Array<ModMetadata>
	{
		// Check if Polymod is loaded.
		if (prevParams == null || assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot load mod "$modId".', INIT);
			return [];
		}

		var newParams = Reflect.copy(prevParams);
		// Add the mod to the list of mods to load.
		newParams.dirs.remove(modId);
		// Keep the same file system between reloads.
		newParams.customFilesystem = assetLibrary.fileSystem;

		return Polymod.init(newParams);
	}

	/**
	 * Reinitializes Polymod (with the same parameters) while additionally disabling several mods.
	 * The specified mods will get removed from the modlist.
	 * If the unloaded mods were dependencies, depending on your configuration,
	 * either dependent mods will also be disabled, or Polymod will throw an error and unload nothing.
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already.
	 * you may have to call `clearCache()` for this to take effect.
	 *
	 * @return A list of all mods that were successfully loaded.
	 */
	public static function unloadMods(modIds:Array<String>):Array<ModMetadata>
	{
		// Check if Polymod is loaded.
		if (prevParams == null || assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot load mod "$modIds".', INIT);
			return [];
		}

		var newParams = Reflect.copy(prevParams);
		// Add the mod to the list of mods to load.
		for (modId in modIds)
		{
			newParams.dirs.remove(modId);
		}
		// Keep the same file system between reloads.
		newParams.customFilesystem = assetLibrary.fileSystem;

		return Polymod.init(newParams);
	}

	/**
	 * Reinitializes Polymod (with the same parameters) while turning off all mods.
	 * If you are using Firetongue integration, localized asset replacements will still apply.
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already.
	 * you may have to call `clearCache()` for this to take effect.
	 */
	public static function unloadAllMods():Void
	{
		// Check if Polymod is loaded.
		if (assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot clear mods.', INIT);
			return;
		}

		var newParams = Reflect.copy(prevParams);
		// Clear the modlist.
		newParams.dirs = [];
		// Keep the same file system between reloads.
		newParams.customFilesystem = assetLibrary.fileSystem;

		Polymod.init(newParams);
	}

	/**
	 * Fully disables Polymod and disables any asset replacements, from mods or from locales.
	 *
	 * Depending on the framework you are using, especially if you loaded a specific file already.
	 * you may have to call `clearCache()` for this to take effect.
	 */
	public static function disable():Void
	{
		// Check if Polymod is loaded.
		if (assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot clear mods.', INIT);
			return;
		}

		assetLibrary.destroy();
		assetLibrary = null;
	}

	/**
	 * Builds the list of files which Polymod will ignore, by default, when loading mods.
	 * Includes license files and metadata files.
	 *
	 * @return A list of filenames.
	 */
	public static function getDefaultIgnoreList():Array<String>
	{
		return PolymodConfig.modIgnoreFiles.concat([PolymodConfig.modMetadataFile, PolymodConfig.modIconFile]);
	}

	/**
	 * Scan the given directory for available mods and returns their metadata entries.
	 * Note that if Polymod is already initialized, all parameters are ignored and optional.
	 *
	 * @param modRoot (optional) root directory of all mods. Optional if Polymod is initialized.
	 * @param apiVersionRule (optional) enforce a modding API version rule -- incompatible mods will not be returned
	 * @param errorCallback (optional) callback for any errors generated during scanning
	 * @return Array<ModMetadata>
	 */
	public static function scan(?scanParams:ScanParams):Array<ModMetadata>
	{
		if (scanParams == null)
		{
			// Scan using assetLibrary's file system.
			if (assetLibrary == null)
			{
				Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot scan for mods.', INIT);
				return [];
			}

			return assetLibrary.fileSystem.scanMods(prevParams.apiVersionRule);
		}
		else
		{
			// Scan using the provided parameters.
			if (scanParams.modRoot == null)
				scanParams.modRoot = './mods';

			if (scanParams.apiVersionRule == null)
				scanParams.apiVersionRule = VersionUtil.DEFAULT_VERSION_RULE;

			if (scanParams.fileSystem == null)
			{
				if (assetLibrary != null)
				{
					scanParams.fileSystem = assetLibrary.fileSystem;
				}
				else
				{
					scanParams.fileSystem = PolymodFileSystem.makeFileSystem(null, {modRoot: scanParams.modRoot});
				}
			}

			return scanParams.fileSystem.scanMods(scanParams.apiVersionRule);
		}
	}

	/**
	 * Tells Polymod to force the current backend to clear any asset caches.
	 */
	public static function clearCache()
	{
		if (assetLibrary == null)
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot clear cache.');
			return;
		}

		Polymod.debug('Clearing backend asset cache...');
		assetLibrary.clearCache();
	}

	/**
	 * Clears all scripted functions and any registered scripted classes from the cache.
	 * This is useful if you want to reload the scripts later.
	 */
	public static function clearScripts():Void
	{
		#if hscript
		@:privateAccess
		polymod.hscript._internal.PolymodScriptClass.clearScriptedClasses();
		polymod.hscript._internal.PolymodEnum.clearScriptedEnums();
		#if hscript_typer
		polymod.hscript._internal.PolymodTyperEx.clearAllModules();
		#end
		polymod.hscript.HScriptable.ScriptRunner.clearScripts();
		#else
		Polymod.warning(SCRIPT_HSCRIPT_NOT_INSTALLED, "Cannot register script classes, HScript is not available.");
		#end
	}

	/**
	 * Get a list of all the available scripted classes (`.hxc` files), interpret them, and register any classes.
	 */
	public static function registerAllScriptClasses():Void
	{
		#if hscript
		@:privateAccess {
			// Go through each script and parse any classes in them.
			var potentialScripts:Array<String> = Polymod.assetLibrary.list(TEXT);
			var libraryIds:Array<String> = Polymod.assetLibrary.listLibraries();

			for (textPath in potentialScripts)
			{
				if (textPath.endsWith(PolymodConfig.scriptClassExt)) {
					var path = textPath;
					if (!Polymod.assetLibrary.exists(path)) {
						trace('Trying libraries: ${libraryIds}');
						for (libraryId in libraryIds) {
							if (Polymod.assetLibrary.exists('$libraryId:$textPath')) {
								trace('Found file in library: $libraryId');
								path = '$libraryId:$textPath';
								break;
							}
						}
						if (!Polymod.assetLibrary.exists(path)) throw 'Couldn\'t find file "$textPath"';
					}
					Polymod.debug('Registering script class "$path"');
					polymod.hscript._internal.PolymodScriptClass.registerScriptClassByPath(path);
				}
			}

			#if hscript_typer
			// in the future typed modules might have a use
			// but for now we just ignore the typed modules that are returned
			var _ = polymod.hscript._internal.PolymodTyperEx.typeAllModules();
			#end

			polymod.hscript._internal.PolymodInterpEx.validateImports(); 
		}
		#else
		Polymod.warning(SCRIPT_HSCRIPT_NOT_INSTALLED, "Cannot register script classes, HScript is not available.");
		#end
	}

	/**
	 * Get a list of all the available scripted classes (`.hxc` files), interpret them asynchronously, and register any classes.
	 * Called on platforms that don't support synchronous file access.
	 */
	public static function registerAllScriptClassesAsync():Array<lime.app.Future<Bool>>
	{
		#if hscript
		// Go through each script and parse any classes in them.
		var potentialScripts:Array<String> = Polymod.assetLibrary.list(TEXT);
		var libraryIds:Array<String> = Polymod.assetLibrary.listLibraries();

		var futures:Array<lime.app.Future<Bool>> = [];
		for (textPath in potentialScripts)
		{
			if (textPath.endsWith(PolymodConfig.scriptClassExt)) {
				var path = textPath;
				if (!Polymod.assetLibrary.exists(path)) {
					for (libraryId in libraryIds) {
						if (Polymod.assetLibrary.exists('$libraryId:$textPath')) {
							trace('Found file in library: $libraryId');
							path = '$libraryId:$textPath';
							break;
						}
					}
					if (!Polymod.assetLibrary.exists(path)) throw 'Couldn\'t find file "$textPath" (tried libraries ${libraryIds})';
				}
				Polymod.debug('Fetching script class "$path"');
				var future = polymod.hscript._internal.PolymodScriptClass.registerScriptClassByPathAsync(path);
				if (future != null) futures.push(future);
			}
		}

		polymod.hscript._internal.PolymodInterpEx.validateImports();

		return futures;
		#else
		Polymod.warning(SCRIPT_HSCRIPT_NOT_INSTALLED, "Cannot register script classes, HScript is not available.");
		#end
	}

	public static function error(code:PolymodErrorCode, message:String, origin:PolymodErrorOrigin = UNKNOWN):Void
	{
		if (onError != null)
		{
			onError(new PolymodError(PolymodErrorType.ERROR, code, message, origin));
		}
	}

	public static function warning(code:PolymodErrorCode, message:String, origin:PolymodErrorOrigin = UNKNOWN):Void
	{
		if (onError != null)
		{
			onError(new PolymodError(PolymodErrorType.WARNING, code, message, origin));
		}
	}

	public static function notice(code:PolymodErrorCode, message:String, origin:PolymodErrorOrigin = UNKNOWN):Void
	{
		if (onError != null)
		{
			onError(new PolymodError(PolymodErrorType.NOTICE, code, message, origin));
		}
	}

	public static function debug(message:String, ?posInfo:haxe.PosInfos):Void
	{
		if (PolymodConfig.debug)
		{
			if (posInfo != null)
				trace('[POLYMOD] (${posInfo.fileName}#${posInfo.lineNumber}): $message');
			else
				trace('[POLYMOD] $message');
		}
	}

	/**
	 * Provide a list of assets included in or modified by the mod(s)
	 * @param type the type of asset you want (lime.utils.PolymodAssetType)
	 * @return Array<String> a list of assets of the matching type
	 */
	public static function listModFiles(type:PolymodAssetType = null):Array<String>
	{
		if (assetLibrary != null)
		{
			return assetLibrary.listModFiles(type);
		}
		else
		{
			Polymod.warning(POLYMOD_NOT_LOADED, 'Polymod is not loaded yet, cannot list files.');
			return [];
		}
	}

	/**
	 * When a scripted class defines an import, you can define another class which should be imported instead.
	 * @param importAlias The full import path to use as an alias, as a string.
	 * @param importClass The class type to import instead.
	 */
	public static function addImportAlias(importAlias:String, importClass:Class<Dynamic>):Void {
		#if hscript
		PolymodScriptClass.importOverrides.set(importAlias, importClass);
		#else
		Polymod.warning(PolymodErrorCode.SCRIPT_HSCRIPT_NOT_INSTALLED, 'Scripted classes imports were requested, but hscript is not installed.');
		#end
	}

	public static function removeImportAlias(importAlias:String):Void {
		#if hscript
		PolymodScriptClass.importOverrides.remove(importAlias);
		#else
		Polymod.warning(PolymodErrorCode.SCRIPT_HSCRIPT_NOT_INSTALLED, 'Scripted classes imports were requested, but hscript is not installed.');
		#end
	}

	/**
	 * Define a class to be imported by default in all scripted classes.
	 * @param importClass The class type to import.
	 * @param importAlias (optional) The alias to use for the import. If not provided, the full class path will be used.
	 */
	public static function addDefaultImport(importClass:Class<Dynamic>, ?importAlias:String):Void {
		#if hscript
		PolymodScriptClass.defaultImports.set(importAlias == null ? Type.getClassName(importClass) : importAlias, importClass);
		#else
		Polymod.warning(PolymodErrorCode.SCRIPT_HSCRIPT_NOT_INSTALLED, 'Scripted classes imports were requested, but hscript is not installed.');
		#end
	}

	/**
	 * When a scripted class define an import, you can blacklist it from being imported.
	 * @param importPath The full import path to blacklist, as a string.
	 */
	public static function blacklistImport(importPath:String):Void {
		#if hscript
		addImportAlias(importPath, null);
		#else
		Polymod.warning(PolymodErrorCode.SCRIPT_HSCRIPT_NOT_INSTALLED, 'Scripted classes imports were requested, but hscript is not installed.');
		#end
	}
}

/**
 * A type representing a contributor to a mod.
 * Allows for providing an optional role and contact information.
 */
typedef ModContributor =
{
	name:String,
	?role:String,
	?email:String,
	?url:String
};

/**
 * A type representing a mod's dependencies.
 *
 * The map takes the mod's ID as the key and the required version as the value.
 * The version follows the Semantic Versioning format, with `*.*.*` meaning any version.
 */
typedef ModDependencies = Map<String, VersionRule>;

/**
 * A type representing data about a mod, as retrieved from its metadata file.
 */
class ModMetadata
{
	/**
	 * The internal ID of the mod.
	 */
	public var id:String;

	/**
	 * The human-readable name of the mod.
	 */
	public var title:String;

	/**
	 * A short description of the mod.
	 */
	public var description:String;

	/**
	 * A link to the homepage for a mod.
	 * Should provide a URL where the mod can be downloaded from.
	 */
	public var homepage:String;

	/**
	 * A version number for the API used by the mod.
	 * Used to prevent compatibility issues with mods when the application changes.
	 */
	public var apiVersion:Version;

	/**
	 * A version number for the mod itself.
	 * Should be provided in the Semantic Versioning format.
	 */
	public var modVersion:Version;

	/**
	 * The name of a license determining the terms of use for the mod.
	 */
	public var license:String;

	/**
	 * Binary data containing information on the mod's icon file, if it exists.
	 * This is useful when you want to display the mod's icon in your application's mod menu.
	 */
	public var icon:Bytes = null;

	/**
	 * The path on the filesystem to the mod's icon file.
	 */
	public var iconPath:String;

	/**
	 * The path where this mod's files are stored, on the IFileSystem.
	 */
	public var modPath:String;

	/**
	 * `metadata` provides an optional list of keys.
	 * These can provide additional information about the mod, specific to your application.
	 */
	public var metadata:Map<String, String>;

	/**
	 * A list of dependencies.
	 * These other mods must be also be loaded in order for this mod to load,
	 * and this mod must be loaded after the dependencies.
	 */
	public var dependencies:ModDependencies;

	/**
	 * A list of dependencies.
	 * This mod must be loaded after the optional dependencies,
	 * but those mods do not necessarily need to be loaded.
	 */
	public var optionalDependencies:ModDependencies;

	/**
	 * A deprecated field representing the mod's author.
	 * Please use the `contributors` field instead.
	 */
	@:deprecated
	public var author(get, set):String;

	// author has been made a property so setting it internally doesn't throw deprecation warnings
	var _author:String;

	function get_author()
	{
		if (contributors.length > 0)
		{
			return contributors[0].name;
		}
		return _author;
	}

	function set_author(v):String
	{
		if (contributors.length == 0)
		{
			contributors.push({name: v});
		}
		else
		{
			contributors[0].name = v;
		}
		return v;
	}

	/**
	 * A list of contributors to the mod.
	 * Provides data about their roles as well as optional contact information.
	 */
	public var contributors:Array<ModContributor>;

	public function new()
	{
		// No-op constructor.
	}

	public function toJsonStr():String
	{
		var json = {};
		Reflect.setField(json, 'title', title);
		Reflect.setField(json, 'description', description);
		// Reflect.setField(json, 'author', _author);
		Reflect.setField(json, 'contributors', contributors);
		Reflect.setField(json, 'homepage', homepage);
		Reflect.setField(json, 'api_version', apiVersion.toString());
		Reflect.setField(json, 'mod_version', modVersion.toString());
		Reflect.setField(json, 'license', license);
		var meta = {};
		for (key in metadata.keys())
		{
			Reflect.setField(meta, key, metadata.get(key));
		}
		Reflect.setField(json, 'metadata', meta);
		return Json.stringify(json, null, '    ');
	}

	public static function fromJsonStr(str:String)
	{
		if (str == null || str == '')
		{
			Polymod.error(PARSE_MOD_META, 'Error parsing mod metadata file, was null or empty.');
			return null;
		}

		var json = null;
		try
		{
			json = haxe.Json.parse(str);
		}
		catch (msg:Dynamic)
		{
			Polymod.error(PARSE_MOD_META, 'Error parsing mod metadata file: (${msg})');
			return null;
		}

		var m = new ModMetadata();
		m.title = JsonHelp.str(json, 'title');
		m.description = JsonHelp.str(json, 'description');
		m._author = JsonHelp.str(json, 'author');
		m.contributors = JsonHelp.arrType(json, 'contributors');
		m.homepage = JsonHelp.str(json, 'homepage');
		var apiVersionStr = JsonHelp.str(json, 'api_version');
		var modVersionStr = JsonHelp.str(json, 'mod_version');
		try
		{
			m.apiVersion = apiVersionStr;
		}
		catch (msg:Dynamic)
		{
			Polymod.error(PARSE_MOD_API_VERSION, 'Error parsing API version: (${msg}) ${PolymodConfig.modMetadataFile} was ${str}');
			return null;
		}
		try
		{
			m.modVersion = modVersionStr;
		}
		catch (msg:Dynamic)
		{
			Polymod.error(PARSE_MOD_VERSION, 'Error parsing mod version: (${msg}) ${PolymodConfig.modMetadataFile} was ${str}');
			return null;
		}
		m.license = JsonHelp.str(json, 'license');
		m.metadata = JsonHelp.mapStr(json, 'metadata');

		m.dependencies = JsonHelp.mapVersionRule(json, 'dependencies');
		m.optionalDependencies = JsonHelp.mapVersionRule(json, 'optionalDependencies');

		return m;
	}
}

/**
 * Structured data on an error that occurred during Polymod's operation.
 */
class PolymodError
{
	/**
	 * Indicates the severity of the issue.
	 * See `PolymodErrorType` for more information.
	 */
	public var severity:PolymodErrorType;

	/**
	 * A particular error which occurred during Polymod's operation.
	 * You can use this with a switch statement to automatically resolve specific errors,
	 * or provide special messages for others.
	 */
	public var code:PolymodErrorCode;

	/**
	 * A human-readable message providing more context for the error which occurred.
	 */
	public var message:String;

	/**
	 * Some brief context on where the error occurred.
	 */
	public var origin:PolymodErrorOrigin;

	public function new(severity:PolymodErrorType, code:PolymodErrorCode, message:String, ?origin:PolymodErrorOrigin = UNKNOWN)
	{
		this.severity = severity;
		this.code = code;
		this.message = message;
		this.origin = origin;
	}
}

/**
 * Indicates where the error occurred.
 */
enum abstract PolymodErrorOrigin(String) from String to String
{
	/**
	 * This error occurred while scanning for mods.
	 */
	var SCAN:String = 'scan';

	/**
	 * This error occurred while initializing Polymod.
	 */
	var INIT:String = 'init';

	/**
	 * This error occurred in an undefined location.
	 */
	var UNKNOWN:String = 'unknown';
}

/**
 * Represents the severity level of a given error.
 */
enum PolymodErrorType
{
	/**
	 * This message is merely an informational notice.
	 * You can handle it with a popup, log it, or simply ignore it.
	 */
	NOTICE;

	/**
	 * This message is a warning.
	 * Either the application developer, the mod developer, or the user did something wrong.
	 */
	WARNING;

	/**
	 * This message indicates a severe error occurred.
	 * This almost certainly will cause unintended behavior. A certain mod may not load or may even cause crashes.
	 */
	ERROR;
}

/**
 * Represents the particular type of error that occurred.
 * Great to use as the condition of a switch statement to provide special handling for specific errors.
 */
enum abstract PolymodErrorCode(String) from String to String
{
	/**
	 * The mod's metadata file could not be parsed.
	 * - Make sure the file contains valid JSON.
	 */
	var PARSE_MOD_META:String = 'parse_mod_meta';

	/**
	 * The mod's version string could not be parsed.
	 * - Make sure the metadata JSON contains a valid Semantic Version string.
	 */
	var PARSE_MOD_VERSION:String = 'parse_mod_version';

	/**
	 * The mod's API version string could not be parsed.
	 * - Make sure the metadata JSON contains a valid Semantic Version string.
	 */
	var PARSE_MOD_API_VERSION:String = 'parse_mod_api_version';

	/**
	 * The app's API version string (passed to Polymod.init) could not be parsed.
	 * - Make sure the string is a valid Semantic Version string.
	 */
	var PARSE_API_VERSION:String = 'parse_api_version';

	/**
	 * Polymod attempted to load a mod, but one or more of its dependencies were missing.
	 * - This is a warning if `skipDependencyErrors` is true, the problematic mod will be skipped.
	 * - This is an error if `skipDependencyErrors` is false, no mods will be loaded.
	 * - Make sure to inform the user that the required mods are missing.
	 */
	var DEPENDENCY_UNMET:String = 'dependency_unmet';

	/**
	 * Polymod attempted to load a mod, and its dependency was found,
	 * but the version number of the dependency did not match that required by the mod.
	 * - This is a warning if `skipDependencyErrors` is true, the problematic mod will be skipped.
	 * - This is an error if `skipDependencyErrors` is false, no mods will be loaded.
	 * - Make sure to inform the user that the required mods have a mismatched version.
	 */
	var DEPENDENCY_VERSION_MISMATCH:String = 'dependency_version_mismatch';

	/**
	 * Polymod attempted to load a mod, but one of its dependencies created a loop.
	 * For example, Mod A requires Mod B, which requires Mod C, which requires Mod A.
	 * - This is a warning if `skipDependencyErrors` is true, the problematic mods will be skipped.
	 * - This is an error if `skipDependencyErrors` is false, no mods will be loaded.
	 * - Inform the mod authors that the dependency issue exists and must be resolved.
	 */
	var DEPENDENCY_CYCLICAL:String = 'dependency_cyclical';

	/**
	 * Polymod was configured to skip dependency checks when loading mods, and that mod order should not be checked.
	 * - Make sure you are certain this behavior is correct and that you have properly configured Polymod.
	 * - This is a warning and can be ignored.
	 */
	var DEPENDENCY_CHECK_SKIPPED:String = 'dependency_check_skipped';

	/**
	 * The given mod's API version does not match the version rule passed to Polymod.init.
	 * - This generally indicates the mod is outdated and should be updated by the author.
	 * - Depending on the changes made between API versions, it may be that the only necessary change is editing the version string in the metadata file.
	 */
	var MOD_API_VERSION_MISMATCH:String = 'mod_api_version_mismatch';

	/**
	 * Polymod tried to access a file that was not found.
	 * - Make sure the file exists before attempting to access it.
	 */
	var FILE_MISSING:String = "file_missing";

	/**
	 * Polymod tried to access a directory that was not found.
	 * - Make sure the directory exists before attempting to access it.
	 */
	var DIRECTORY_MISSING:String = "directory_missing";

	/**
	 * You requested a mod to be loaded but that mod was not installed.
	 * - Make sure a mod with that ID is installed.
	 * - Make sure to run Polymod.scan to get the list of valid mod IDs.
	 */
	var MISSING_MOD:String = 'missing_mod';

	/**
	 * You requested a mod to be loaded but its mod folder is missing a metadata file.
	 * - Make sure the mod folder contains a metadata JSON file. Polymod won't recognize the mod without it.
	 */
	var MISSING_META:String = 'missing_meta';

	/**
	 * A mod with the given ID is missing an icon file.
	 * - This is a warning and can be ignored. Polymod will still load your mod, but it looks better if you add an icon.
	 * - The default location for icons is `_polymod_icon.png`.
	 */
	var MISSING_ICON:String = 'missing_icon';

	/**
	 * We are preparing to load a particular mod.
	 * - This is an info message. You can log it or ignore it if you like.
	 */
	var MOD_LOAD_PREPARE:String = 'mod_load_prepare';

	/**
	 * We couldn't load a particular mod.
	 * - There will generally be a warning or error before this indicating the reason for the error.
	 */
	var MOD_LOAD_FAILED:String = 'mod_load_failed';

	/**
	 * We have successfully completed loading a particular mod.
	 * - This is an info message. You can log it or ignore it if you like.
	 * - This is also a good trigger for a UI indicator like a toast notification.
	 */
	var MOD_LOAD_DONE:String = 'mod_load_done';

	/**
	 * You passed a bad argument to Polymod.init({customFilesystem}).
	 * - Ensure the input is either an IFileSystem or a Class<IFileSystem>.
	 */
	var BAD_CUSTOM_FILESYSTEM:String = 'bad_custom_filesystem';

	/**
	 * You attempted to perform an operation that requires Polymod to be initialized.
	 * - Make sure you call Polymod.init before attempting to call this function.
	 */
	var POLYMOD_NOT_LOADED:String = 'polymod_not_loaded';

	/**
	 * Script classes are currently disabled because the `hscript` library is not available.
	 * - Make sure you have the `hscript` Haxelib installed if you want to use scripts.
	 */
	var SCRIPT_HSCRIPT_NOT_INSTALLED:String = 'script_hscript_not_installed';

	/**
	 * A script file of the given name could not be found.
	 * - This happens when calling annotated functions in an HScriptable class when no script file exists.
	 * - Make sure the script file exists in the proper location in your assets folder.
	 * - Alternatively, you can expand your annotation to `@:hscript({optional: true})` to disable the error message,
	 *     if your function can resolve properly without a script.
	 */
	var SCRIPT_NOT_FOUND:String = 'script_not_found';

	/**
	 * The scripted class does not import an `Assets` class to handle script loading.
	 * - When loading scripts, the target of the HScriptable interface will call `Assets.getText` to read the relevant script file.
	 * - You will need to import `openfl.util.Assets` on the HScriptable class, even if you don't otherwise use it.
	 */
	 var SCRIPT_NO_ASSET_HANDLER:String = 'script_no_asset_handler';

	/**
	 * You attempted to instantiate a scripted class that was not registered.
	 * - Make sure your script is in the assets folder.
	 * - Make sure that `useScriptedClasses` in your Polymod.init parameters is set to true.
	 * - If your scripted class extends another class, make sure that class exists as well.
	 */
	var SCRIPT_CLASS_NOT_REGISTERED:String = 'script_class_not_registered';

	/**
	 * You attempted to register a new scripted class with a name that is already in use.
	 * - Rename the scripted class to one that is unique and will not conflict with other scripted classes.
	 * - You can also use a package name to avoid conflicts, although you may have to refer to the class by its full name in some places.
	 * - If you need to clear all existing class descriptors, call `Polymod.clearScripts()`.
	 */
	var SCRIPT_CLASS_ALREADY_REGISTERED:String = 'script_class_already_registered';

	/**
	 * Your script file attempted to import a class that was already imported.
	 * - This is a warning and can be ignored.
	 * - Remove the duplicate import statement to remove the warning.
	 */
	var SCRIPT_CLASS_MODULE_ALREADY_IMPORTED:String = 'script_class_module_already_imported';

	/**
	 * Your script file attempted to import a class that could not be resolved.
	 * - Check the syntax of the import statement, and check for any typos.
	 */
	var SCRIPT_CLASS_MODULE_NOT_FOUND:String = 'script_class_module_not_found';

	/**
	 * Your script file attempted to import a blacklisted class.
	 * - This is a security measure to prevent malicious scripts from accessing sensitive classes.
	 * - Remove the import statement to remove the error.
	 */
	var SCRIPT_CLASS_MODULE_BLACKLISTED:String = 'script_class_module_blacklisted';

	/**
	 * You attempted to register a new enum with a name that is already in use.
	 * - Rename the enum to one that is unique and will not conflict with other enums.
	 * - If you need to clear all existing enum descriptors, call `Polymod.clearScripts()`.
	 */
	 var SCRIPT_ENUM_ALREADY_REGISTERED:String = 'script_enum_already_registered';

	/**
	 * One or more scripts are about to be parsed.
	 * - This is an info message. You can log it or ignore it if you like.
	 */
	var SCRIPT_PARSING:String = 'script_parsing';

	/**
	 * One or more scripts have been successfully parsed.
	 * - This is an info message. You can log it or ignore it if you like.
	 */
	var SCRIPT_PARSED:String = 'script_parsed';

	/**
	 * A script file could not be parsed for some unknown reason.
	 * - Check the syntax of the script file is proper Haxe.
	 * - Read the error message for more information.
	 */
	var SCRIPT_PARSE_ERROR:String = 'script_parse_error';

	/**
	 * While running a script, an exception was thrown.
	 * - Read the error message for more information.
	 * - Scripted functions will have the local variable `script_error` assigned, allowing you to handle the error gracefully.
	 */
	var SCRIPT_RUNTIME_EXCEPTION:String = 'script_runtime_exception';

	/**
	 * An installed mod is looking for another mod with a specific version, but the mod is not of that version.
	 * - The mod may be a modpack that includes that mod, or it may be a mod that has the other mod as a dependency.
	 * - Inform your users to install the proper mod version.
	 */
	var VERSION_CONFLICT_MOD:String = 'version_conflict_mod';

	/**
	 * The mod has an API version that conflicts with the application's API version.
	 * - This means that the mod needs to be updated, checking for compatibility issues with any changes to API version.
	 * - If you're getting this error even for patch versions, be sure to tweak the `POLYMOD_API_VERSION_MATCH` config option.
	 */
	var VERSION_CONFLICT_API:String = 'version_conflict_api';

	/**
	 * One of the version strings you provided to Polymod.init is invalid.
	 * - Make sure you're using a valid Semantic Version string.
	 */
	var PARAM_MOD_VERSION:String = 'param_mod_version';

	/**
	 * Indicates what asset framework Polymod has automatically detected for use.
	 * - This is an info message, and can either be logged or ignored.
	 */
	var FRAMEWORK_AUTODETECT:String = 'framework_autodetect';

	/**
	 * Indicates what asset framework Polymod has been manually configured to use.
	 * - This is an info message, and can either be logged or ignored.
	 */
	var FRAMEWORK_INIT:String = 'framework_init';

	/**
	 * You configured Polymod to use the `CUSTOM` asset framework, then didn't provide a value for `params.customBackend`.
	 * - Define a class which extends IBackend, and provide it to Polymod.
	 */
	var UNDEFINED_CUSTOM_BACKEND:String = 'undefined_custom_backend';

	/**
	 * Polymod could not create an instance of the class you provided for `params.customBackend`.
	 * - Check that the class extends IBackend, and can be instantiated properly.
	 */
	var FAILED_CREATE_BACKEND:String = 'failed_create_backend';

	/**
	 * You attempted to use a functionality of Polymod that is not fully implemented, or not implemented for the current framework.
	 * - Report the issue here, and describe your setup and provide the error message:
	 *   https://github.com/larsiusprime/polymod/issues
	 */
	var FUNCTIONALITY_NOT_IMPLEMENTED:String = 'functionality_not_implemented';

	/**
	 * You attempted to use a functionality of Polymod that has been deprecated and has/will be significantly reworked or altered.
	 * - New features and their associated documentation will be provided in future updates.
	 */
	var FUNCTIONALITY_DEPRECATED:String = 'functionality_deprecated';

	/**
	 * There was a warning or error attempting to perform a merge operation on a file.
	 * - Check the source and target files are correctly formatted and try again.
	 */
	var MERGE:String = 'merge_error';

	/**
	 * There was a warning or error attempting to perform an append operation on a file.
	 * - Check the source and target files are correctly formatted and try again.
	 */
	var APPEND:String = 'append_error';

	/**
	 * On the Lime and OpenFL platforms, if the base app defines multiple asset libraries,
	 * each asset library must be assigned a path to allow mods to override their files.
	 * - Provide a `frameworkParams.assetLibraryPaths` object to Polymod.init().
	 */
	var LIME_MISSING_ASSET_LIBRARY_INFO = 'lime_missing_asset_library_info';

	/**
	 * On the Lime and OpenFL platforms, if the base app defines multiple asset libraries,
	 * each asset library must be assigned a path to allow mods to override their files.
	 * - All libraries must have a value under `frameworkParams.assetLibraryPaths`.
	 * - Set the value to `./` to fetch assets from the root of the mod folder.
	 */
	var LIME_MISSING_ASSET_LIBRARY_REFERENCE = 'lime_missing_asset_library_reference';
}
